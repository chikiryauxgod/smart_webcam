// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: result_service.proto

#include "result_service.pb.h"
#include "result_service.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/channel_interface.h>
#include <grpcpp/impl/client_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/rpc_service_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/sync_stream.h>
namespace result_service {

static const char* VideoStream_method_names[] = {
  "/result_service.VideoStream/StreamVideo",
};

std::unique_ptr< VideoStream::Stub> VideoStream::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< VideoStream::Stub> stub(new VideoStream::Stub(channel, options));
  return stub;
}

VideoStream::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_StreamVideo_(VideoStream_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::BIDI_STREAMING, channel)
  {}

::grpc::ClientReaderWriter< ::result_service::Frame, ::result_service::Result>* VideoStream::Stub::StreamVideoRaw(::grpc::ClientContext* context) {
  return ::grpc::internal::ClientReaderWriterFactory< ::result_service::Frame, ::result_service::Result>::Create(channel_.get(), rpcmethod_StreamVideo_, context);
}

void VideoStream::Stub::async::StreamVideo(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::result_service::Frame,::result_service::Result>* reactor) {
  ::grpc::internal::ClientCallbackReaderWriterFactory< ::result_service::Frame,::result_service::Result>::Create(stub_->channel_.get(), stub_->rpcmethod_StreamVideo_, context, reactor);
}

::grpc::ClientAsyncReaderWriter< ::result_service::Frame, ::result_service::Result>* VideoStream::Stub::AsyncStreamVideoRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc::internal::ClientAsyncReaderWriterFactory< ::result_service::Frame, ::result_service::Result>::Create(channel_.get(), cq, rpcmethod_StreamVideo_, context, true, tag);
}

::grpc::ClientAsyncReaderWriter< ::result_service::Frame, ::result_service::Result>* VideoStream::Stub::PrepareAsyncStreamVideoRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncReaderWriterFactory< ::result_service::Frame, ::result_service::Result>::Create(channel_.get(), cq, rpcmethod_StreamVideo_, context, false, nullptr);
}

VideoStream::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      VideoStream_method_names[0],
      ::grpc::internal::RpcMethod::BIDI_STREAMING,
      new ::grpc::internal::BidiStreamingHandler< VideoStream::Service, ::result_service::Frame, ::result_service::Result>(
          [](VideoStream::Service* service,
             ::grpc::ServerContext* ctx,
             ::grpc::ServerReaderWriter<::result_service::Result,
             ::result_service::Frame>* stream) {
               return service->StreamVideo(ctx, stream);
             }, this)));
}

VideoStream::Service::~Service() {
}

::grpc::Status VideoStream::Service::StreamVideo(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::result_service::Result, ::result_service::Frame>* stream) {
  (void) context;
  (void) stream;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace result_service

